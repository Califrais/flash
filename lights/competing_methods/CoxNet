library(lcmm)
library(glmnet)

# function to get features
lfeatures <- function(model, formFixed, formRandom, data.id, col_name = "") {
    data.id$T_long <- data.id$T_survival
    mfX.id <- model.frame(formFixed, data = data.id)
    mfU.id <- model.frame(formRandom, data = data.id)
    Xtime <- model.matrix(formFixed, mfX.id)
    Utime <- model.matrix(formRandom, mfU.id)

    # subject-specific random effects
    RE <- model$predRE[, -1]
    value <- Xtime %*% model$best[1:ncol(Xtime)] + diag(Utime %*% t(RE))
    return(value)
}

Cox_get_long_feat <- function(data, time_dep_feat, time_indep_feat, alpha) {
    # all features
    X <- c()
    data.id <- data[!duplicated(as.integer(data[all.vars(~id)][, 1])), ]
    long_model <- list()
    long_feat <- list()
    for(i in 1:length(time_dep_feat)) {
        formFixed = as.formula(paste(time_dep_feat[[i]], " ~ T_long + I(T_long^alpha)"))
        formRandom = ~T_long
        long_model[[i]] <- hlme(fixed = formFixed, random = formRandom, subject = "id", ng = 1, data = data)
        long_feat[[i]] <- lfeatures(model = long_model[[i]],
                               formFixed = formFixed, formRandom = formRandom,
                               col_name = time_dep_feat[i], data.id = data.id)
        # combine longitudinal features
        X <- cbind(X, long_feat[[i]])
    }
    for(i in 1:length(time_indep_feat)) {
        time_indep <- data.id[[time_indep_feat[[i]]]]
        # combine time-independent features
        X <- cbind(X, time_indep)
    }
    colnames(X) <- cbind(time_dep_feat, time_indep_feat)
    return(X)
}

Cox_cross_val <- function(X, T, delta) {
    cv.coxnet.fit <- cv.glmnet(X, Surv(T, delta), family = "cox", alpha = 1, nfolds = 10)
    # use the best penality parameter
    best.lambda <- cv.coxnet.fit$lambda.min

    return(best.lambda)
}

Cox_fit <- function(X, T, delta, lambda) {
    coxnet.fit <- glmnet(X, Surv(T, delta),
                        family = "cox", lambda = lambda, alpha = 1)
    return(coxnet.fit)
}

Cox_score <- function(trained_model, X) {
    # predictive marker
    p_coxph_en <- predict(trained_model, newx = X, type = "response")

    return(p_coxph_en)
}